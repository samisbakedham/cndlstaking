import merge from 'lodash.merge';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let apiKey = "torus-default";
let embedHost = "";
// #region API Keys
const gatewayAuthHeader = "x-api-key";
const gatewayEmbedHostHeader = "x-embed-host";
function setEmbedHost(embedHost_) {
    embedHost = embedHost_;
}
function clearEmbedHost() {
    embedHost = "";
}
function getEmbedHost() {
    return embedHost;
}
function setAPIKey(apiKey_) {
    apiKey = apiKey_;
}
function clearAPIKey() {
    apiKey = "torus-default";
}
function getAPIKey() {
    return apiKey;
}
// #endregion
function getApiKeyHeaders() {
    const headers = {};
    if (apiKey)
        headers[gatewayAuthHeader] = apiKey;
    if (embedHost)
        headers[gatewayEmbedHostHeader] = embedHost;
    return headers;
}
const promiseTimeout = (ms, promise) => {
    const timeout = new Promise((resolve, reject) => {
        const id = setTimeout(() => {
            clearTimeout(id);
            reject(new Error(`Timed out in ${ms}ms`));
        }, ms);
    });
    return Promise.race([promise, timeout]);
};
const get = (url, options_ = {}, customOptions = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const defaultOptions = {
        mode: "cors",
        headers: {},
    };
    if (customOptions.useAPIKey) {
        defaultOptions.headers = Object.assign(Object.assign({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = merge(defaultOptions, options_, { method: "GET" });
    const response = yield fetch(url, options);
    if (response.ok) {
        return response.json();
    }
    throw response;
});
const post = (url, data = {}, options_ = {}, customOptions = {}) => {
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    };
    if (customOptions.useAPIKey) {
        defaultOptions.headers = Object.assign(Object.assign({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = merge(defaultOptions, options_, { method: "POST" });
    // deep merge changes the structure of form data and url encoded data ,
    // so we should not deepmerge body data
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8")
            delete options.headers["Content-Type"];
    }
    else {
        options.body = JSON.stringify(data);
    }
    return promiseTimeout(customOptions.timeout || 60000, fetch(url, options).then((response) => {
        if (response.ok) {
            return response.json();
        }
        throw response;
    }));
};
const patch = (url, data = {}, options_ = {}, customOptions = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    };
    // for multipart request browser/client will add multipart content type
    // along with multipart boundary , so for multipart request send
    // content-type: undefined or send with multipart boundary if already known
    if (customOptions.useAPIKey) {
        defaultOptions.headers = Object.assign(Object.assign({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = merge(defaultOptions, options_, { method: "PATCH" });
    // deep merge changes the structure of form data and url encoded data ,
    // so we should not deepmerge body data
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8")
            delete options.headers["Content-Type"];
    }
    else {
        options.body = JSON.stringify(data);
    }
    const response = yield fetch(url, options);
    if (response.ok) {
        return response.json();
    }
    throw response;
});
const remove = (url, data = {}, options_ = {}, customOptions = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const defaultOptions = {
        mode: "cors",
        headers: {
            "Content-Type": "application/json; charset=utf-8",
        },
    };
    // for multipart request browser/client will add multipart content type
    // along with multipart boundary , so for multipart request send
    // content-type: undefined or send with multipart boundary if already known
    if (customOptions.useAPIKey) {
        defaultOptions.headers = Object.assign(Object.assign({}, defaultOptions.headers), getApiKeyHeaders());
    }
    const options = merge(defaultOptions, options_, { method: "DELETE" });
    if (customOptions.isUrlEncodedData) {
        // for multipart request browser/client will add multipart content type
        // along with multipart boundary , so for multipart request send
        // content-type: undefined or send with multipart boundary if already known
        options.body = data;
        // If url encoded data, this must not be the content type
        if (options.headers["Content-Type"] === "application/json; charset=utf-8")
            delete options.headers["Content-Type"];
    }
    else {
        options.body = JSON.stringify(data);
    }
    const response = yield fetch(url, options);
    if (response.ok) {
        return response.json();
    }
    throw response;
});
const generateJsonRPCObject = (method, parameters) => ({
    jsonrpc: "2.0",
    method,
    id: 10,
    params: parameters,
});
const promiseRace = (url, options, timeout = 60000) => Promise.race([
    get(url, options),
    new Promise((resolve, reject) => {
        setTimeout(() => {
            reject(new Error("timed out"));
        }, timeout);
    }),
]);

export { clearAPIKey, clearEmbedHost, gatewayAuthHeader, gatewayEmbedHostHeader, generateJsonRPCObject, get, getAPIKey, getEmbedHost, patch, post, promiseRace, promiseTimeout, remove, setAPIKey, setEmbedHost };
//# sourceMappingURL=httpHelpers.esm.js.map
